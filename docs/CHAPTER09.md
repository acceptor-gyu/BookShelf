# 오브젝트 - 9장 <유연한 설계>

## 제목을 보고 든 생각
- 지금까지 나왔던 인터페이스의 활용 등으로 다형성을 설명하며 유지보수하기 쉬운 코드를 작성하는 내용이 나올 것같다. 

## 목차
1. 개방-폐쇄 원칙
2. 생성 사용 분리
3. 의존성 주입
4. 의존성 역전 원칙
5. 유연성에 대한 조언


## 이번 장의 목표
- 유연하고 재사용 가능한 설계를 만들기 위해 적용할 수 있는 다양한 의존성 관리 기법들을 원칙의 관점에서 이해할 수 있다.
- 설계를 논의할 때 사용할 수 있는 공통의 어휘를 익히는 것의 가치를 안다. 

## 읽으면서 쓴 단어들
1. 개방-폐쇄 원칙
> #확장 #수정 #동작 #코드  
> #컴파일타임 의존성 #런타임 의존성
> #추상화 #의존

2. 생성 사용 분리
> 

3. 의존성 주입
> 

4. 의존성 역전 원칙
> 

5. 유연성에 대한 조언
>


## 정리
1. 개방-폐쇄 원칙
- 추상화는 설계의 확장을 가능하게 한다.
- 변경에 의한 파급효과를 최대한 피하기 위해서는 변하는 것과 변하지 않는 것이 무엇인지를 이해하고 이를 추상화의 목적으로 삼아야만 한다.

> 추상화가 수정에 대해 닫혀있을 수 있는 이유는 변경되지 않을 부분을 신중하게 결정하고  
> 올바른 추상화를 주의 깊게 선택했기 떄문이라는 사실을 기억하라.

2. 생성 사용 분리
- 

3. 의존성 주입
- 

4. 의존성 역전 원칙
- 

5. 유연성에 대한 조언
- 


## 새롭게 다가온 부분
p.282
- 확장에 대해 열려 있다
  - 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 `동작`을 추가해서 애플리ㅔ이션의 기능을 확장할 수 있다.
- 수정에 대해 닫혀 있다
  - 기존의 `코드`를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.

p.283
- 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라
  > 의존성 관점에서 개방-폐쇄 원칙을 따르는 설계란 컴파일타임 의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조라고 할 수 있다.

p.284
- 개방-폐새 원칙의 핵심은 `추상화에 의존하는 것`이다.
  - 추상화 과정을 거치면 문맥이 바뀌더라도 변하지 않는 부분만 남게 되고 문맥에 따라 변하는 부분은 생략된다.
  - 추상화를 사용하면 생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다.
- 개방-폐쇄 원칙에 관점에서 생략되지 않고 남겨지는 부분은 다양한 상황에서의 공통점을 반영한 `추상화의 결과물`이다.
  - 따라서 추상화 부분은 수정에 닫혀 있다.
  - 추상화를 통해 생략된 부분은 확장의 여지를 남긴다.
  - 이것이 추상화가 개방-폐쇄 원칙을 가능하게 만드는 이유다.

p.285
- 단순히 어떤 개념을 추상화했다고 해서 수정에 대해 닫혀 있는 설계를 만들 수 있는 것은 아니다.
  - 개방-폐쇄 원칙에서 폐쇄를 가능하게 하는 것은 의존성의 방향이다.
  - 수정에 대한 영향을 최소화하기 위해서는 모든 요소가 추상화에 의존해야 한다.


## 궁금한 부분

## 느낀 점
- 이 책을 읽으면서 항상 느낀 부분이지만 추상적으로만 알고 있던 개념들을 문장으로 설명을 해줘서 명확해졌다.
  - 새로운 기능을 추가할 때 기존의 코드는 수정하지 않은 채 해당 기능의 클래스를 추가만 해도 새로운 컨텍스트에 사용되도록 확장할 수 있다는 것이
  - 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경한 것이고
  - 확장에 대해 열려 있고, 수정에 대해 닫혀있는 것이다.


## 개념
- `개방-폐쇄 원칙(Open-Closed Principle, OCP)`: 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
- `추상화`: 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기

## 한 줄 정리
