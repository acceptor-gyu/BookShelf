# 오브젝트 - 9장 <유연한 설계>

## 제목을 보고 든 생각
- 지금까지 나왔던 인터페이스의 활용 등으로 다형성을 설명하며 유지보수하기 쉬운 코드를 작성하는 내용이 나올 것같다. 

## 목차
1. 개방-폐쇄 원칙
2. 생성 사용 분리
3. 의존성 주입
4. 의존성 역전 원칙
5. 유연성에 대한 조언


## 이번 장의 목표
- 유연하고 재사용 가능한 설계를 만들기 위해 적용할 수 있는 다양한 의존성 관리 기법들을 원칙의 관점에서 이해할 수 있다.
- 설계를 논의할 때 사용할 수 있는 공통의 어휘를 익히는 것의 가치를 안다. 

## 읽으면서 쓴 단어들
1. 개방-폐쇄 원칙
> #확장 #수정 #동작 #코드  
> #컴파일타임 의존성 #런타임 의존성
> #추상화 #의존

2. 생성 사용 분리
> #객체에 대한 생성과 사용을 분리  
> #인공적인 객체

3. 의존성 주입
> #숨겨진 의존성 

4. 의존성 역전 원칙
> #협력 #의존성의 방향 #컨텍스트에 독립적인 설계

5. 유연성에 대한 조언
> #유연한 설계와 복잡성


## 정리
1. 개방-폐쇄 원칙
- 추상화는 설계의 확장을 가능하게 한다.
- 변경에 의한 파급효과를 최대한 피하기 위해서는 변하는 것과 변하지 않는 것이 무엇인지를 이해하고 이를 추상화의 목적으로 삼아야만 한다.

> 추상화가 수정에 대해 닫혀있을 수 있는 이유는 변경되지 않을 부분을 신중하게 결정하고  
> 올바른 추상화를 주의 깊게 선택했기 떄문이라는 사실을 기억하라.

2. 생성 사용 분리
- 객체 생성과 관련된 책임만 전담하는 별도의 객체를 추가하고 Client는 이 객체를 사용하도록 만들 수 있다.
- 이처럼 생성과 사용을 분리하기 위해 객체 생성에 특화된 객체를 `FACTORY`라고 부른다.

- FACTORY는 전체적으로 결합도를 낮추고 재사용성을 높이기 위해 
- 도메인 개념에 할당돼 있던 객체 생성 책임을 도메인 개념과는 아무런 상관이 없는 가공의 객체로 이동시키기 위해 추가한 것이다.

- 어떤 행동을 추가하려고 하는데 이 행동을 책임질 마땅한 도메인 개념이 존재하지 않는다면 `순수한 가공물(PURE FABRICATION)`을 추가하고 이 객체에게 책임을 할당하라.
  - 그 결과로 추가된 순수한 가공물은 보통 특정한 행동을 표현하는 것이 일반적이다.
  - 따라서 순수한 가공물은 표현적 분해보다는 행위적 분해에 의해 생성되는 것이 일반적이다.

3. 의존성 주입
- `의존성 주입`은 의존성을 해결하기 위해 의존성을 객체의 퍼블릭 인터페이스에 명시적으로 드러내서 외부에서 필요한 런타임 의존성을 전달할 수 있도록 만드는 방법을 포괄하는 명칭
- 의존성 주입에서는 의존성을 해결하는 세 가지 방법이 있다.
  - setter 주입은 의존성의 대상을 런타임에 변경할 수 있지만, 언제라도 의존 대상을 교체할 수 있다.
  - 또, 객체가 올바로 생성되기 위해 어떤 의존성이 필수적인지를 명시적으로 표현할 수 없다는 것이다.
  - setter 메서드는 생성된 후에 호출되어야 하기 때문에 setter 메서드 호출을 누락한다면 객체는 비정상적인 상태로 생성될 것이다.
- 숨겨진 의존성은 문제점을 발견할 수 있는 시점을 코드 작성 시점이 아니라 실행 시점으로 미루기 떄문에 이해하기 코드를 이해하기 어렵고 디버깅하기 어렵다.
- 의존성을 숨기는 코드는 단위 테스트 작성도 어렵다.

> 명시적인 의존성이 숨겨진 의존성보다 좋을 것이다.  
> 가급적 의존성을 객체의 퍼블릭 인터페이스에 노출하라.

4. 의존성 역전 원칙
- 훌륭한 객체지향 설계를 위해서는 의존성을 역전시켜야 한다. 그리고 의존성을 역전시켜야만 유연하고 재사용 가능한 설계를 얻을 수 있다.

5. 유연성에 대한 조언
- 우리는 정적인 프로그램과 동적인 프로세스 사이의 간극을 줄이기 위해 최선을 다해야 하며, 이를 통해 프로그램(텍스트 공간에 흩뿌려진)과 진행 과정 사이를 가능한 한 일치시켜야 한다.
- 역할, 책임, 협력에 먼저 집중하자.
- 객체를 생성하는 방법에 대한 결정은 모든 책임이 자리를 잡은 후 가장 마지막 시점에 내리는 것이 적절할 것이다!


## 새롭게 다가온 부분
p.282
- 확장에 대해 열려 있다.
  - 애플리케이션의 요구사항이 변경될 때 이 변경에 맞게 새로운 `동작`을 추가해서 애플리케이션의 기능을 확장할 수 있다.
- 수정에 대해 닫혀 있다.
  - 기존의 `코드`를 수정하지 않고도 애플리케이션의 동작을 추가하거나 변경할 수 있다.

p.283
- 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경하라
  > 의존성 관점에서 개방-폐쇄 원칙을 따르는 설계란 컴파일타임 의존성은 유지하면서 런타임 의존성의 가능성을 확장하고 수정할 수 있는 구조라고 할 수 있다.

p.284
- 개방-폐쇄 원칙의 핵심은 `추상화에 의존하는 것`이다.
  - 추상화 과정을 거치면 문맥이 바뀌더라도 변하지 않는 부분만 남게 되고 문맥에 따라 변하는 부분은 생략된다.
  - 추상화를 사용하면 생략된 부분을 문맥에 적합한 내용으로 채워넣음으로써 각 문맥에 적합하게 기능을 구체화하고 확장할 수 있다.
- 개방-폐쇄 원칙에 관점에서 생략되지 않고 남겨지는 부분은 다양한 상황에서의 공통점을 반영한 `추상화의 결과물`이다.
  - 따라서 추상화 부분은 수정에 닫혀 있다.
  - 추상화를 통해 생략된 부분은 확장의 여지를 남긴다.
  - 이것이 추상화가 개방-폐쇄 원칙을 가능하게 만드는 이유다.

p.285
- 단순히 어떤 개념을 추상화했다고 해서 수정에 대해 닫혀 있는 설계를 만들 수 있는 것은 아니다.
  - 개방-폐쇄 원칙에서 폐쇄를 가능하게 하는 것은 의존성의 방향이다.
  - 수정에 대한 영향을 최소화하기 위해서는 모든 요소가 추상화에 의존해야 한다.

p.288
- 유연하고 재사용 가능한 설계를 원한다면 객체와 관련된 두 가지 책임을 서로 다른 객체로 분리해야 한다.
  - 하나는 객체를 생성하는 것이고,
  - 다른 하나는 객체를 사용하는 것이다.
  - 한 마디로 말해서 객체에 대한 `생성과 사용을 분리`해야 한다.
> 소프트웨어 시스템은 시작 단계와 실행 단계를 분리해야 한다.

p.292
- 도메인의 본질적인 개념을 표현하는 추상화를 이용해 애플리케이션을 구축하기 시작하라.
- 만약 도메인 개념이 만족스럽지 못하다면 주저하지 말고 인공적인 객체를 창조하라.
- 우리가 애플리케이션을 구축하는 것은 사용자들이 원하는 기능을 제공하기 위해서지 실세계를 모방하거나 시뮬레이션하기 위한 것이 아니다.
- 도메인을 반영하는 애플리케이션이 구조라는 제약 안에서 실용적인 창조성을 발휘할 수 있는 능력은 훌륭한 설계자가 갖춰야 할 기본적인 자질이다.

p. 299
- 접근해야 할 객체가 있다면 전역 매커니즘 대신, 필요한 객체를 인수로 넘겨줄 수는 없는지부터 생각해보자.

p.301
- 대부분의 경우 우리가 재사용하려는 대상의 상위 수준의 클래스일 것이다.                                                                                                                                                                                

p.302
- `역전(inversion)`이라는 단어를 사용한 이유는 의존성 역전 원칙을 따르는 설계는 의존성의 방향이 전통적인 절차형 프로그래밍과는 반대 방향으로 나타나기 때문이다.

p.303!!
- SEPARATED INTERFACE 패턴
  - 이 책의 예제 코드에서 Movie의 재사용을 위해 필요한 것이 DiscountPolicy뿐이라면 DiscountPolicy를 Movie와 같은 패키지로 모으고
  - AmountDiscountPolicy와 PercentDiscountPolicy를 별도의 패키지에 위치시켜 의존성 문제를 해결할 수 있다.
  - > 추상화를 별도의 독립적인 패키지가 아니라 클라이언트가 속한 패키지(Movie, DiscountPolicy)에 포함시켜야 한다.  
    > 그리고 함께 재사용될 필요가 없는 클래스들(AmountDiscountPolicy, PercentDiscountPolicy)은 별도의 독립적인 패키지에 모아야 한다. 

> 컨텍스트에 독립적인 설게!!!

## 궁금한 부분
- 도메인(도메인 모델)이란?
  - 

## 느낀 점
- 이 책을 읽으면서 항상 느낀 부분이지만 추상적으로만 알고 있던 개념들을 문장으로 설명을 해줘서 명확해졌다.
  - 새로운 기능을 추가할 때 기존의 코드는 수정하지 않은 채 해당 기능의 클래스를 추가만 해도 새로운 컨텍스트에 사용되도록 확장할 수 있다는 것이
  - 컴파일타임 의존성을 고정시키고 런타임 의존성을 변경한 것이고
  - 확장에 대해 열려 있고, 수정에 대해 닫혀있는 것이다.


## 개념
- `개방-폐쇄 원칙(Open-Closed Principle, OCP)`: 소프트웨어 개체(클래스, 모듈, 함수 등)는 확장에 대해 열려 있어야 하고, 수정에 대해서는 닫혀 있어야 한다.
- `추상화`: 핵심적인 부분만 남기고 불필요한 부분은 생략함으로써 복잡성을 극복하는 기법
- `표현적 분해`: 도메인에 존재하는 사물 또는 개념을 표현하는 객체들을 이용해 시스템을 분해하는 것
  - 표현적 분해는 도메인 모델에 담겨 있는 개념과 관계를 따르며 도메인과 소프트웨어 사이의 표현적 차이를 최소화하는 것을 목적으로 한다.
  - 따라서 표현적 분해는 객체지향 설계를 위한 가장 기본적인 접근법이다.
- `순수한 가공물`: 책임을 할당하기 위해 창조되는 도메인과 무관한 인공적인 객체 (도메인 개념을 표현한 객체가 아닌 설계자가 편의를 위해 임의로 만들어낸 가공의 객체)
- `의존성 주입(Dependency Injection)`: 사용하는 객체가 아닌 외부의 독립적인 객체가 인스턴스를 생성한 후 이를 전달해서 의존성을 해결하는 방법
  - `생성자 주입`: 객체를 생성하는 시점에 생성자를 통한 의존성 해결
  - `setter 주입`: 객체 생성 후 setter 메서드를 통한 의존성 해결
  - `메서드 주입`: 메서드 실행 시 인자를 이용한 의존성 해결
- `SERVICE LOCATOR`: 의존성을 해결할 객체들을 보관하는 일종의 저장소

## 한 줄 정리
- 어떤 책이 나한테 의미있는 내용이 한 문장이라도 있다면 나는 그 책을 사서 읽을 것이다.
  - 이번 장에서는 p.303 내용이 그것인 것같다.