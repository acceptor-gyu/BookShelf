# 최신 웹을 위한 도큐먼트 데이터베이스

주요 내용
- MongoDB의 역사, 설계 목표, 핵심 기능
- 셸과 드라이버에 대한 간략한 소개
- 사용 예와 한계
- 최근의 MongoDB 변화

개발자들은 왜 MongoDB에 관심을 갖는가?
- MongoDB는 웹 애플리케이션과 인터넷 기반을 위해 설계된 데이터베이스 관리 시스템이다.
- 데이터 모델과 지속성 전략은 높은 읽기/쓰기 효율과 자동 장애조치(failover)를 통한 확장의 용이성을 염두에 두고 만들어졌다

> 애프리케이션에서 필요한 데이터베이스 노드의 개수와 관계없이 MongoDB는 좋은 성능을 보여준다.

개발자들은 확장성보다는 직관적인 데이터 모델때문에 MongoDB를 선호할 것이다.

```mongodb-json
{
  _id: 10,
  username: 'acceptor-gyu',
  email: 'gseonggyu968@gmail.com'
}
```
위 도큐먼트와 같은 모델의 장점은 무엇일까?

관계 모델에서 테이블을 나누고 조인을 해야하겠지만, MongoDB는 다른 방법을 제공한다.
```mongodb-json
{
  _id: 10,
  username: 'acceptor-gyu',
  email: [
    'gseonggyu968@gmail.com',
    'tjdrb0402@hansung.ac.kr'
  ]
}
```
- 스키마(schema)에 맞춰야하는 걱정 없이 구조화된 도큐먼트를 데이터베이스에 저장할 수 있다.

> 도큐먼트 기반 모델은 특정 작업에 잘 맞출 수 있고, 
> 스키마가 없는 것은 MongoDB가 애플리케이션 상에서 빠르게 개발하고 반복할 수 있는 최고의 도구 중 하나가 될 수 있음을 뜻한다.  
> 저자의 목표는 독자들이 MongoDB를 사용하는 것이 옳은 일인지 아닌지를 결정할 수 있게 필요한 정보를 제공하고 효과적으로 이용할 수 있게 설명하는 것이다.

## 1.1 인터넷에서 태어나다
하드웨어와 소프트웨어 인프라 등 기술 계층을 직접 제어할 수 없는 점을 불편하게 생각하는 개발자들이 10gen의 새로운 데이터베이스 기술을 원했다.  
10gen은 이러한 요구를 충족시키기 위해 MongoDB를 만들었다.

그 후 10gen은 회사 이름을 MongoDB로 바꾸고, 오픈 소스 프로젝트로서 데이터베이스 개발을 계속 지원하고 있다.  
코드는 공개되어 있고, 라이선스 조건에 따라 자유롭게 수정하거나 사용할 수 있으며, 커뮤니티는 일반적인 버그 리포트를 올리고 패치를 제공한다.

프로젝트의 로드맵은 사용자 커뮤니티의 필요에 의해, 
그리고 관계 데이터베이스와 키-값(key-value) 분산 저장 시스템의 가장 좋은 기능들만을 통합하는 데이터베이스의 설계라는 주요 목표에 의해 결정된다.

MongoDB의 역사에서 가장 중요한 것은 MongoDB는 매우 간단하지만 유연하고 웹 애플리케이션 계층의 일부로 개발되었다는 점이다.  
이러한 사용 예는 MongoDB 개발을 선택하도록 만들고, MongoDB의 특징을 설명할 수 있도록 도와준다.

## 1.2 MongoDB의 핵심 기능
> - 도큐먼트 데이터 모델
> - 이 모델에 대해 효과적으로 수행되는 MongoDB의 기능
> - MongoDB의 복제와 수평 확장을 중심으로한 데이터베이스 연산


### 도큐먼트 데이터 모델
`도큐먼트(document)`는 본질적으로 속성의 이름과 값으로 이루어진 쌍의 집합이다.

MongoDB는 Binary JSON 혹은 BSON의 형태로 도큐먼트를 저장한다. 즉, MongoDB는 도큐먼트의 모음과 같이 데이터를 `컬렉션(Collection)`에 도큐먼트로 저장한다.

컬렉션은 MongoDB에서 중요한 개념이다. 컬렉션에 있는 데이터는 디스크로 저장되고, 대부분의 쿼리에서 찾고자 하는 컬렉션이 무엇인지 명시해야 할 것이다.

> 일대다 대응 관계를 표현하기 위해서 여러 개의 테이블이 필요한 관계 모델과는 다르게  
> 도큐먼트 지향적인 데이터 모델에서는 객체를 자연스럽게 모아 놓은 형태로 표현함으로써 객체를 전체적으로 작업할 수 있다.

MongoDB는 도큐먼트를 컬렉션으로 모아 놓는데, 어떤 종류의 스키마도 필요하지 않는다.
이론적으로는 하나의 컬렉션에 포함되어 있는 각각의 도큐먼트들이 서로 완전히 다른 구조를 갖는 것도 가능하다.  
하지만 실제로는 컬렉션 내에서 도큐먼트들은 상대적으로 균일한 구조를 갖는다.


<스키마가 없는 모델의 장점>
1. 데이터베이스가 아닌 애플리케이션이 데이터 구조를 정한다.
   - 데이터의 구조가 빈번히 변경되는 개발 초기 단계에서 개발 속도를 단축시켜 준다.

2. 스키마가 없는 데이터 모델을 통해 가변적인 속성을 갖는 데이터를 표현할 수 있다는 것이다.
   - 조인이 필요 없고, 새로운 속성은 한 도큐먼트에 동적으로 추가할 수 있다.
   - 애플리케이션 개발을 할 때 추후에 필요한 데이터 필드가 무엇인지에 대해서는 걱정할 필요가 없다.

### 애드혹 쿼리
시스템이 `애드혹 쿼리(ad hoc query)`를 지원한다고 하는 것은 시스템이 받아들일 수 있는 질의를 미리 정의할 필요가 없다는 것이다.  
RDBMS가 이 기능을 제공하는데, 질의가 어떠한 조건을 갖더라도 올바른 구조이기만 하면 SQL 쿼리가 실행된다. (모든 데이터베이스가 동적 질의를 지원하는 것은 아니다.)  
다른 많은 시스템에서와 같이 키-값 저장 시스템 역시 간단하고 확장성 높은 모델을 위해 풍부한 쿼리 기능을 포기한다.

> MongoDB의 설계 목표 중 하나는 관계형 데이터베이스 상에서 필수적인 쿼리 언어 성능을 대부분 유지하는 것이다.

MongoDB에서 쿼리 언어가 어떻게 작동하는지 보기 위해 예를 들어보자.
- 추천 수가 10 이상의 'politics'라는 용어로 태그된 포스트를 찾으려면 SQL 쿼리 언어는 다음과 같다.
```sql
SELECT * FROM posts 
         INNER JOIN posts_tags ON posts.id = posts_tage.post_id
         INNER JOIN tags ON posts_tags.tag_id == tags.id
         WHERE tags.text = 'politics' AND posts.vote_count > 10
```
- MongoDB에서는 다음과 같다.
```ruby
db.posts.find({
  tags: 'politics',
  vote_count: { $gt: 10 }
});
```

> 두 쿼리 모두 여러 개의 속성을 임의로 조합하여 질의할 수 있는 능력을 보여 주고 있는데, 이러한 것이 애드혹 쿼리의 본질적인 강점이다.

### 인덱스
MongoDB에서 인덱스는 `B-트리(B-tree)`로 구현되어 있다.  
`WiredTiger`는 `LSM(Log-Structured Merge Tree)` 인덱스를 지원하며, MongoDB 3.2 정식 배포판부터 이용할 수 있다.

MongoDB에서도 프라이머리 키는 자동적으로 인덱스되어 각 기준은 유니크 키(unique key)를 이용하여 효과적으로 기억된다.  
하지만 모든 데이터베이스가 행 또는 도큐먼트에 대한 인덱스 작업을 허용하는 것은 아니다.
이들은 `세컨더리 인덱스(secondardy index)`라고 불린다. HBase와 같은 많은 NoSQL 데이터베이스는 `키-값 저장소(key-value store)`로 간주되는데,
이는 그 어떤 세컨더리 인덱스도 지원하지 않는다.  
이는 MongoDB에서 매우 중요한 특징인데, 여러 개의 세컨더리 인덱스를 허용함으로써 MongoDB는 사용자가 넓은 범위의 쿼리를 최적화하도록 허용한다.

MongoDB에서는 한 컬렉션에 64개까지 세컨더리 인덱스까지 만들 수 있다.
오름차순, 내림차순, 고유(unique), 복합 키(compound-key), 해시, 텍스트, 지리공간적 인덱스와 같이 관계 데이터베이스 시스템에서 볼 수 있는 모든 인덱스가 가능하다.

> 지리공간적 인덱스는 효과적으로 위도와 경도를 질의할 수 있도록 해준다.

> MongoDB v3.6
> - WiredTiger 엔진은 v3.0부터 도입되었으며, v3.0에서는 MMAPv1이 디폴트 엔진이다. 단, v3.0에서는 WiredTiger 엔진을 사용할 수 있도록 설정할 수 있다.
> - v3.2부터는 WiredTiger 엔진이 디폴트 엔진이다.

### 복제
MongoDB는 `복제 세트(replica set)`라고 부르는 구성을 통해 데이터베이스 복제(replication) 기능을 제공한다.
복제 세트는 서버와 네트워크 장애가 발생할 경우를 대비해 중복성과 장애조치 자동화를 위해 데이터를 여러 대의 서버에 분산한다.
복제는 데이터 베이스 읽기에 대한 확장을 위해서도 사용된다.

복제 세트의 각각의 MongoDB 서버는 분리된 물리 장비에 별도로 존재하며, 이를 노드(node)라 부른다.
어느 순간이든지 하나의 노드는 복제 세트의 프라이머리 노드(primary node)로 존재하며, 더불어 하나 또는 그 이상의 세컨더리 노드가 존재한다.

프라이머리 노드에 대해서는 읽기와 쓰기가 모두 가능하지만, 세컨더리 노드는 읽기만 가능하다.  

> 복제 세트의 고유한 기능은 자동 장애조치를 지원한다는 점이다. 

### 속도와 내구성
데이터베이스 시스템에서는 쓰기 속도와 내구성 사이에 역관계가 존재한다.  
`쓰기 속도(write speed)`는 미리 정해진 시간 내에 데이터베이스가 얼마나 많은 수의 삽입, 수정, 삭제를 처리할 수 있는지를 의미한다.  
`내구성(durability)`은 이 쓰기 연산이 디스크에 제대로 이루어졌다는 것을 확신할 수 있는 정도를 의미한다.

> *트랜잭션 로그

MongoDB의 경우에는 쓰기 시맨틱스(write semantics)와 저널링(journaling)을 통해 속도와 내구성 사이에서 타협을 이룰 수 있다

fire-and-forget 모드로 설정하면 확인을 기다릴 필요 없이 서버에 쓰기 작업을 전송할 수 있다.
또한, 커밋(commit)이 되었는지 확인하기 전에 다수의 복제 서버들에 대한 쓰기를 보장하도록 설정할 수도 있다.

단위 데이터는 작지만 양은 방대한 데이터에 대해서는 fire-and-forget 타입의 쓰기가 적합할 것이고,  
중요한 데이터의 경우에는 안전 모드 쓰기가 더 나을 것이다.


`저널링(journaling)`은 모든 쓰기에 대한 로그를 100ms마다 한 번씩 저널 파일에 기록한다.
서버가 불시에 셧다운되면 저널은 MongoDB 파일을 복구해서 서버를 재시작할 때 원래의 상태를 유지하는 데 이용된다.
이것이 MongoDB를 실행하는 가장 안전한 방법이다.

쓰기 부하에 대한 성능을 향상시키기 위해 저널링을 하지 않은 채 서버를 실행할 수 있다.
이렇게 할 때의 단점은 불시에 셧다운 될 때 데이터 파일이 손상될 수 있다는 점이다.
그 결과, 저널링을 사용하지 않는 경우에는 장애가 발생하더라도 손상되지 않은 데이터 복사본을 가질 가능성을 높이기 위해서 또 다른 데이터 센터에서 데이터베이스를 복제해야 한다.

## 1.3 MongoDB 코어 서버와 툴









## 1.4 MongoDB를 사용하는 이유







## 1.5 팁과 한계





## 1.6 MongoDB의 역사



## 1.7 추가적인 자료




## 1.8 요약



## detail
> 도큐먼트 데이터베이스란?
>   - 도큐먼트 데이터베이스는 관계형 데이터베이스와 달리 스키마가 없다.

> 개체-속성-값 패턴
>   - http://en.wikipeda.org/wiki/Entity-attribute-value_model

> WiredTiger
 
> LSM(Log-Structured Merge Tree)

> 세컨더리 인덱스(secondardy index)

> Write-Ahead Logging(WAL)

> 트랜잭션 로그  
> 속도와 내구성 사이의 타협은 MySQL의 InnoDB에서 볼 수 있다. InnoDB는 트랜잭션 저장 엔진인데, 이 정의에 따라 내구성이 보장된다.
> 쓰기 연산이 트랜잭션 로그와 메모리 버퍼 풀, 두 곳에 수행됨으로써 내구성이 보장된다. 트랜잭션 로그는 디스크와 바로 동기화가 되고, 버퍼 풀은 백그라운드 스레드에 의해 나중에 동기화된다.
> 이렇게 이중으로 쓰기를 수행하는 이유는 일반적으로 랜덤 I/O가 순차 I/O보다 훨씬 더 느리기 때문이다. 
> 데이터 파일에 대한 쓰기 연산은 랜덤 I/O로 이루어지므로 램을 먼저 업데이트를 하고 디스크에 대한 동기화는 나중에 하게 된다.
> 하지만 내구성을 보장하기 위해 디스크에 대한 쓰기가 필요하므로 쓰기 연산이 순차적으로 되는 것이 중요하다.  
> 바로 이것 때문에 트랜잭션 로그가 순차적으로 쓰여지는 것이다. 불시에 셧다운되는 경우에 InnoDB는 트랜잭션 로그를 재실행해서 주 데이터 파일을 업데이트할 수 있게 된다/
> 이렇게 함으로써 성능은 그대로 유지하면서 높은 내구성을 보장할 수 있게 된다.

> 쓰기 시맨틱스(write semantics)와 저널링(journaling)