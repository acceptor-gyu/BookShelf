# 오브젝트 - 6장 <메시지와 인터페이스>


## 제목을 보고 든 생각
- 지금까지 내용을 생각하면 행동과 역할 할당에 관련된 내용이 나올 것같다.

## 목차
1. 협력과 메시지
2. 인터페이스와 설계 품질
3. 원칙의 함정
4. 명령-쿼리 분리 법칙


## 이번 장의 목표
- 협력 안에서 객체가 수행하는 책임에 초점을 맞추도록 생각을 하자.
- 책임이 객체가 수신할 수 있는 메시지의 기반이 될 것이다!
- 유연하고 재사용 가능한 퍼블릭 인터페이스를 만드는 데 도움이 되는 설계 원칙과 기법을 익히고 적용하는 방법을 공부한다.


## 읽으면서 쓴 단어들
1. 협력과 메시지
> #협력 #메시지 #클라이언트-서버 모델

2. 인터페이스와 설계 품질
> 

3. 원칙의 함정
>

4. 명령-쿼리 분리 법칙
> #루틴 #프로시저 

## 정리
1. 협력과 메시지
- 동일한 이름의 변수에게 동일한 메시지를 전송하더라도 객체의 타입에 따라 실해오디는 메서드가 다를 수 있다.
  - 이전에 컴파일 시점과 런타임 시점과 관련해서 나온 다형성과 같은 말이겠지?

> 객체가 수신할 수 있는 메시지가 객체의 퍼블릭 인터페이스와 그 안에 포함될 오퍼레이션을 결정할 것이다.  
> 객체의 퍼블릭 인터페이스가 객체의 품질을 결정하기 때문에 결국 메시지가 객체의 품질을 결정한다고 할 수 있다.

2. 인터페이스와 설계 품질


3. 원칙의 함정


4. 명령-쿼리 분리 법칙
- 명령-쿼리 분리 법칙
  - 기계 메타포와 함께 설명을 읽으니 이해가 잘 되었다.
  - 그리고 이를 이해하기 위해서 자료구조(JCF)를 생각해봤다.
  - queue.add()는 부수효과를 일으키지만 값을 반환하지 않는다.
  - queue.poll()는 부수효과를 일으키면서 값을 반환한다.
    - 어떻게 된건가? 명령-쿼리 분리 원칙을 지키지 않은건가?
    - 앞에서도 말했듯이 원칙은 트레이드 오프의 부산물이기 때문에 꼭 지켜야할 필요는 없다.
    - 안지켰을 수도 있다. 하지만 다르게 생각을 해보자.
    - queue.poll()의 return으로 peek()을 준다면 어느정도 이해가 되긴 한다.
  - 위의 생각은 단순히 명령-쿼리 분리 법칙을 이해하기 위해서 생각한 것일 뿐 실제로 뭐가 맞는 지는 찾아봐야 할 것이다.

---
> 책임을 할당하고 그거에 따라서 완벽하게 상태가 나오는게 아니다보니 비현실적인 부분들이 많은 것같다.  
> 그래서 이런 말들을 보면 책이니까 어느 정도의 FM을 만들어놓고 말을 하고 있지만 
> 그게 현실적으로 좀 힘들다보니까 OOP가 어떤 느낌인지 좀 알아가고 OOP에 어울리는 설계를 하면서 
> 본인만의 방식을 만들어 나가야하는 것같다.

> 같은 말을 다르게 설명하는 것처럼 느껴지는 지금 시점에서 이번 미션에 적용시켜보면서 좋은 경험이 되었다.


## 새롭게 다가온 부분
p.175
- 애플리케이션은 클래스로 구성되지만 `메시지를 통해 정의`된다.
- 객체가 수신하는 메시지들이 객체의 퍼블릭 인터페이스를 구성한다.

p.179
- 메시지와 메서드의 구분은 메시지 전송자와 메시지 수신자가 `느슨하게 결합`될 수 있게 한다.
  - 메시지 전송자는 자신이 어떤 메시지를 전송해야 하는지만 알면 된다.
  - 수신자가 어떤 클래스의 인스턴스인지, 어떤 방식으로 요청을 처리하는지 모르더라도 원활한 협력이 가능하다.
  - 메시지 수신자는 누가 메시지를 전송하는지 알 필요가 없다.
  - 메시지 수신자는 메시지를 처리히기 위해 필요한 메서드를 `스스로 결정할 수 있는 자율권`을 누린다.

> 머리로는 이해가 된 상태였지만 코드에 적용시켰을 때, 이게 맞는지 의문이 들 때가 많았던 부분이다.  

p.186
- 메시지 전송자는 메시지 수신자의 상태를 기반으로 결정을 내린 후 메시지 수신자의 상태를 바꿔서는 안된다.

p.188
- 메서드 이름에 '어떻게'를 드러내는 것은 메서드 수준에서 캡슐화를 위반하는 것이다.
  - 내부적으로 '어떻게'가 바뀌면 메서드 이름도 바꿔야 할 것이다.
  - 위 내용을 보기 전까지는 "'어떻게'를 외부에 드러내는 것이라서 캡슐화를 위반하는 것이라고 말을 하는건가"라는 생각을 했었다.



## 다른 사람들에게 궁금한 부분


## 개념
- `메시지`: 객체가 다른 객체와 협력하기 위해 사용하는 의사소통 메커니즘
  - 일반적으로 객체의 오퍼레이션이 실행되도록 요청하는 것을 `메시지 전송`이라고 부른다.
  - 메시지는 협력에 참여하는 전송자와 수신자 양쪽 모두를 포함하는 개념이다.
- `오퍼레이션`: 객체가 다른 객체에게 제공하는 추상적인 서비스
  - 메시지는 전송자와 수신자 사이의 협력 관계를 강조하는 데 비해 오퍼레이션은 메시지를 수신하는 객체의 인터페이스를 강조한다.
  - 즉, 전송자는 고려하지 않은 채 메시지 수신자의 관점만을 다룬다.
  - 메시지 수신이란 메시지에 대응되는 객체의 오퍼레이션을 호출하는 것이다.
- `메서드`: 메시지에 응답하기 위해 실행되는 코드 블록
  - 메서드는 오퍼레이션의 구현이다.
  - 동일한 오퍼레이션이라고 해도 메서드는 다를 수 있다.
  - 오퍼레이션과 메서드의 구분은 다형성의 개념과 연결된다.
- `퍼블릭 인터페이스`: 객체가 협력에 참여하기 위해 외부에서 수신할 수 있는 메시지의 묶음.
- `시그니처`: 오퍼레이션이나 메서드의 명세


## 한 줄 정리

