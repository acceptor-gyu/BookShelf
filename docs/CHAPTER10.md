# 오브젝트 - 10장 <상속과 코드 재사용>

## 제목을 보고 든 생각
- 상속의 개념을 이용해 코드의 중복을 줄이는 내용이 나올 것같다.

## 목차
1. 상속과 중복 코드
2. 취약한 기반 클래스 문제
3. Phone 다시 살펴보기
4. 차이에 의한 프로그래밍

## 이번 장의 목표
- 클래스를 재사용하기 위해 새로운 클래스를 추가하는 대표적인 기법인 `상속`에 관해 이해한다.

## 읽으면서 쓴 단어들
1. 상속과 중복 코드
> #DRY 원칙 #변경 #취약한 기반 클래스

2. 취약한 기반 클래스 문제
> #취약한 기반 클래스 #결합도 

3. Phone 다시 살펴보기
> #추상화

4. 차이에 의한 프로그래밍
> #


## 정리
1. 상속과 중복 코드
- 중복 코드를 제거해야 하는 가장 큰 이유는 중복 코드는 `변경을 방해`하기 때문이다.

- 상속은 중복 코드를 제거할 수 있지만 `결합도를 높인다.`
  - 그리고 상속이 초래하는 부모 클래스와 자식 클래스 사이의 강한 결합이 코드를 수정하기 어렵게 만든다.

2. 취약한 기반 클래스 문제
- 상속은 자식 클래스가 부모 클래스의 구현 세부사항에 의존하도록 만들기 때문에 캡슐화를 약화시킨다.
  - 상속을 사용하면 부모 클래스의 `퍼블릭 인터페이스`가 아닌 구현을 변경하더라도 자식 클래스가 영향을 받기 쉬워진다.

- 객체를 사용하는 이유는 구현과 관련된 세부사항을 퍼블릭 인터페이스 뒤로 캡슐화할 수 있기 떄문이다!
> 객체지향의 기반은 캡슐화를 통한 변경의 통제다.  
> 상속은 코드의 재사용을 위해 캡슐화의 장점을 희석시키고 구현에 대한 결합도를 높임으로써 객체지향이 가진 강력함을 반감시킨다.

3. Phone 다시 살펴보기
- 상속의 문제를 해결하는 가장 일반적인 방법은 자식 클래스가 부모 클래스의 구현이 아닌 `추상화`에 의존하도록 만드는 것이다.
  - 정확하게 말하면 부모 클래스와 자식 클래스 모두 추상화에 의존하도록 수정해야 한다.

- 공통 코드를 이동시킨 후에 각 클래스는 서로 다른 변경의 이유를 가진다는 것에 주목하자!

> 상속 계층이 코드를 진화시키는 데 걸림돌이 된다면 추상화를 찾아내고 상속 계층 안의 클래스들이 그 추상화에 의존하도록 코드를 리팩터링하라.  
> 차이점을 메서드로 추출하고 공통적인 부분은 부모 클래스로 이동하라.

> 상속은 어떤 방식으로든 부모 클래스와 자식 클래스를 결합시킨다.  
> 우리가 원하는 것은 행동을 변경하기 위해 인스턴스 변수를 추가하더라도 `상속 계층 전체에 걸쳐 부작용이 퍼지지 않게 막는 것`이다.

4. 차이에 의한 프로그래밍
- 프로그래밍의 세계에서 중복 코드는 악의 근원이다.
- 상속의 오용과 남용은 애플리케이션을 이해하고 확장하기 어렵게 만든다.
- 정말로 필요한 경우에만 상속을 사용하라.

> 상속은 코드 재사용과 관련된 대부분의 경우에 우아한 해결 방법이 아니다.  
> 객체지향에 능숙한 개발자들은 상속의 단점을 피하면서도 코드를 재사용할 수 있는 더 좋은 방법이 있다는 사실을 알고 있다.  
> 바로 `합성`이다.

## 새롭게 다가온 부분
p.309
- 중복 여부를 판단하는 기준은 변경이다.
  - 중복 코드를 결정하는 기준은 코드의 모양이 아니다.
  - 코드가 변경에 반응하는 방식이다.

p.320
- 상속을 염두에 두고 설계되지 않은 클래스를 상속을 이용해 재사용하는 것은 생각처럼 쉽지 않다.
  - 개발자는 재사용을 위해 `상속 계층 사이에 무수히 많은 가정`을 세웠을지도 모른다.
  - 그리고 그 가정은 코드를 이해하기 어렵게 만들뿐만 아니라 직관에도 어긋날 수 있다.
  > 주석이 필요없는 코드를 작성하지 못한다면
  > 주석을 달아야 하는 이유가 아닐까?

p. 333
- 저자가 코드 중복을 제거하기 위해 상속을 도입할 때 따르는 두 가지 원칙
  1. 두 메서드가 유사하게 보인다면 차이점을 메서드로 추출하라. 
     1. 메서드 추출을 통해 두 메서드를 동일한 형태로 보이도록 만들 수 있다.
  2. 부모 클래스의 코드를 하위로 내리지 말고 자식 클래스의 코드를 상위로 올려라.
     1. 부모 클래스의 구체적인 메서드를 자식 클래스로 내리는 것보다 자식 클래스의 추상적인 메서드를 부모 클래스로 올리는 것이 재사용성과 응집도 측면에서 더 뛰어난 결과를 얻을 수 있다.

- 차이를 메서드로 추출하라
  - `변하는 것으로부터 변하지 않는 것을 분리하라`
  - `변하는 부분을 찾고 이를 캡슐화하라`

p.343
- 인스턴스 변수릐 목록이 변하지 않는 상황에서 객체의 행동만 변경된다면 상속 계층에 속한 각 클래스들을 독립적으로 진화시킬 수 있다.
- 하지만 인스턴스 변수가 추가되는 경우는 다르다.
- 자식 클래스는 자신의 인스턴스를 생성할 때 부모 클래스에 정의된 인스턴스 변수를 초기화해야 하기 때문에 자연스럽게 부모 클래스에 추가된 인스턴스 변수는 클래스의 초기화 로직에 영향을 미치게 된다.
- 결과적으로 책임을 아무리 잘 분리하더라도 인스턴스 변수의 추가는 종종 상속 계층 전반에 걸친 변경을 유발한다.
> 하지만 인스턴스 초기화 로직을 변경하는 것이 두 클래스의 동일한 세금 계산 코드를 중복시키는 것보다는 현명한 선택이다.  
> 객체 생성 로직에 대한 변경을 막기보다는 `핵심 로직의 중복을 막아라`  
> 핵심 로직은 한 곳에 모아 놓고 조심스럽게 캡슐화해야 한다. 그리고 공통적인 핵심 로직은 최대한 추상화해야 한다.

## 상속을 위한 경고
### 상속을 위한 경고1
> 자식 클래스의 메서드 안에서 super 참조를 이용해 부모 클래스의 메서드를 직접 호출할 경우 두 클래스는 강하게 결합된다.  
> super 호출을 제거할 수 있는 방법을 찾아 결합도를 제거하라

### 상속을 위한 경고2
> 상속받은 부모 클래스의 메서드가 자식 클래스의 내부 구조에 대한 규칙을 깨트릴 수 있다.

### 상속을 위한 경고3
> 자식 클래스가 부모 클래스의 메서드를 오버라이딩할 경우 부모 클래스가 자신의 메서드를 사용하는 방법에 자식 클래스가 결합될 수 있다.

### 상속을 위한 경고4
> 클래스를 상속하면 결합도로 인해 자식 클래스와 부모 클래스의 구현을 영원히 변경하지 않거나, 자식 클래스와 부모 클래스를 동시에 변경하거나 둘 중 하나를 션택할 수밖에 없다.

## 느낀 점
- 객체지향에서 상속을 권장하지 않는 이유에 대해서 정리되었다.

p.329
- 설계는 `트레이드 오프` 활동이라는 사실을 기억하라
- 상속은 코드 재사용을 위해 캡슐화를 희생한다.
- 완벽한 캡슐화를 원한다면 코드 재사용을 포기하거나 상속 이외의 다른 방법을 사용해야 한다.

## 개념
- `DRY 원칙`: 반복하지 마라.(Don't Repeat Yourself)
  - `한 번, 단 한번 원칙` 또는 `단일 지점 제어 원칙`이라고도 부른다.
- `결합도`: 다른 대상에 대해 알고 있는 지식의 양

## 한 줄 정리
- 상속은 OOP에서 권장하지 않는 기법(다른 방법이 있는 경우) 중에 하나로 알고 있었다.
- 상속과 같이 나오는 `합성`이 다음 장에 나온다니 다음 장이 기대된다.