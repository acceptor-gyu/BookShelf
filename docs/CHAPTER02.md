# 오브젝트 - 2장 <객체지향 프로그래밍>

## 목차
1. 영화 예매 시스템
2. 객체지향 프로그래밍을 향해
3. 할인 요금 구하기
4. 상속과 다형성
5. 추상화와 유연성

## 이번 장의 목표
> 이 책의 다양한 주제들을 가볍게 살펴보기

## 읽으면서 쓴 단어들
1. 영화 예매 시스템
- 영화 예매 시스템의 목적과 개념, 할인과 관련된 규칙에 대한 내용이었다.
> 생략

2. 객체지향 프로그래밍을 향해
> #객체를 지향 #객체에 초점 #협력 #공동체  
> #DDD #도메인  
> #자율성 #접근 제어(access control) #접근 수정자(access modifier)  
> #상태(state) #행동(behavior)
> #클래스 작성자 #클라이언트 프로그래머 #구현 은닉  
> #협력(Collaboration) #request #response #메시지

3. 할인 요금 구하기
> #다형성(polymporphism) #상속

4. 상속과 다형성
> #의존성 #상속 #인터페이스

5. 추상화와 유연성
>



## 정리
1. 영화 예매 시스템
- 영화 예매 시스템의 목적과 개념, 할인과 관련된 규칙에 대한 내용이었다.
> 생략

2. 객체지향 프로그래밍을 향해
- 객체는 상태(state)와 행동(behavior)을 갖고 스스로 판단하고 행동하는 자율적인 존재다.
- 객체 내부에 대한 접근을 통제하는 이유는 객체에 자율성을 부여하기 위함이다.
- 클래스를 개발할 때마다 인터페이스와 구현을 깔끔하게 분리하기 위해 노력해야 한다.
  - 클래스 작성자 입장에서는 자유롭게 구현을 변경할 수 있는 범위가 넓어진다.
  - 클라이언트 프로그래머 입장에서는 알아야 할 지식의 양이 줄어든다.
- 설계가 필요한 이유는 변경에 용이한 코드를 작성하기 위해서다.
  - 변경을 용이하게 할 수 있는 기법 중에 하나는 접근 제어다.

3. 할인 요금 구하기
- 영화관의 할인 시스템에 관한 코드 설명에 대한 내용이 메인인 파트였다.
- 설계한 것을 문법적인 차원에서 깔끔하게 맞아떨어지도록 구현할 수 있다는 것을 보여준 부분이 매우 인상깊었다. 

4. 상속과 다형성
- 유연성 vs 가독성
  - 코드의 의존성과 실행 시점에서 의존성이 다를 수 있다. 즉, 클래스 간의 의존성과 객체 간의 의존성은 동일하지 않을 수 있다.
  - 코드의 의존성과 실행 시점에서 의존성이 다를수록 유연하고 재사용하기 쉬운 코드를 작성하기 좋아지지만, 코드를 이해하기 어려워진다. 객체지향 프로그래밍에서는 이와 같은 `트레이드오프`를 항상 고려해야 한다.
- 상속이 가치 있는 이유는 부모 클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있다는 것이다.
  - 인터페이스는 객체가 이해할 수 있는 메시지 목록을 정의한다는 것이다.
  - 즉, 자식 클래스는 부모 클래스가 수신할 수 있는 모든 메시지를 수신할 수 있다는 것이다.
- 다형성은 객체지향 프로그램의 컴파일 시간 의존성과 실행 시간 의존성이 다를 수 있다는 사실을 기반으로 한다.
- 다형적인 협력에 참여하는 객체들은 인터페이스가 동일해야 한다.


## 새롭게 다가온 부분
1. 금액과 관련된 다양한 계산을 Money라는 클래스로 만든다.
- 단순히 Long 또는 Integer 타입을 사용하면 변수의 크기나 연산자의 종류와 관련된 구현 관점의 제약은 표현할 수 있지만 Money 타입처럼 저장하는 값이 금액과 관련되어 있다는 의미를 전달할 수는 없다.
- 또한 Money 클래스를 만들면 금액과 관련된 로직이 서로 다른 곳에 중복되어 구현되는 것을 막을 수 있다.

```java
import java.math.BigDecimal;

public class Money {
  public static final Money ZERO = Money.wons(0);

  private final BigDecimal amount;
  
  public static Money wons(long amount) {
      return new Money(BigDecimal.valueOf(amount));
  }
  
  ...
}
```
> - 객체지향의 장점은 객체를 이용해 도메인의 의미를 풍부하게 표현할 수 있다는 것이다.  
> - 따라서 의미를 좀 더 명시적이고 분명하게 표현할 수 있다면 객체를 사용해서 해당 개념을 구현하라.
> - 그 개념이 비록 하나의 인스턴스 변수만 포함하더라도 개념을 명시적으로 표현하는 것은 전체적인 설계의 명확성과 유연성을 높이는 첫 걸음이다.

2. 협력에 관한 내용
- 객체 간의 상호작용, 협력을 메시지 전송/응답으로 설명하는 부분이 인상었다.
- 특히, 어떤 객체가 메시지를 전송하면 메시지를 수신한 객체가 `스스로의 결정에 따라 자율적으로 처리`할 방법을 결정한다. 라는 내용이 객체의 자율성을 이야기하는 이 책의 맥락에 퍼즐처럼 끼워 맞춰지는 느낌이 들어 꽤나 인상깊었고 적잖이 충격적이었다.

3. 상속
- 컴파일러는 코드 상에서 부모 클래스가 나오는 모든 곳에서 자식 클래스를 사용하는 것을 허용한다.


## 개념
- 도메인: 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야
  - ex) 영화를 쉽고 빠르게 예매해려는 사용자의 문제를 해결하는 것
- 접근 제어(access control): 외부에서의 접근을 통제
- 접근 수정자(access modifier)
  - ex) public, protected, private
- 퍼블릭 인터페이스(public interface): 외부에서 객체에 접근 가능한 부분
- 구현(implements): 외부에서의 접근이 불가능하고 오직 내부에서만 접근 가능한 부분
- 인터페이스와 구현의 분리 원칙(separation of interface and implementation)
- abstract class는 인스턴스를 생성할 필요가 없을 떄 선언할 수 있다.
- 업캐스팅(upcasting): 자식 클래스가 부모 클래스를 대신하는 것
- 다형성(polymorphism): 동일한 메시지를 수신했을 때 객체의 타입에 따라 다르게 응답할 수 있는 능력
- 구현 상속(서브 클래싱)과 인터페이스 상속(서브 타이핑)
  - 구현 상속: 순수하게 코드를 재사용하기 위한 목적으로 상속을 사용하는 것
  - 인터페이스 상속: 다형적인 협력을 위해 부모 클래스와 자식 클래스가 인터페이스를 공유할 수 있도록 상속을 사용하는 것
  - 상속은 구현 상속이 아니라 인터페이스 상속을 위해 사용해야 한다. 구현을 재사용할 목적으로 상속을 사용하면 변경에 취약한 코드를 낳게 될 확률이 높다.

## 한 줄 정리
> Object is FREE