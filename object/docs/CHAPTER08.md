# 오브젝트 - 8장 <의존성 관리하기>

## 제목을 보고 든 생각
- 세부적인 내용을 예측하기는 어렵지만, 객체들 간의 협력과 관련된 내용이 나올 것같다.

## 목차
1. 의존성 이해하기
2. 유연한 설계

## 이번 장의 목표
- 객체지향 설계란 의존성을 관리하는 것이고 객체가 변화를 받아들일 수 있게 의존성을 정리하는 기술임을 안다.

## 읽으면서 쓴 단어들
1. 의존성 이해하기
> #의존성 #실행 시점 #구현 시점 
> #의존성 전이 #직접 의존성 #간접 의존성 #런타임 의존성 #컴파일 타임 의존성

1- 컨텍스트 독립성 (p.260)
> #구체적인 클래스 #문맥 #컨텍스트 독립성

2. 유연한 설계
> #의존성의 정도 #바람직한 의존성 #재사용성  
> #느슨한 결합도 #약한 결합도  
> #단단한 결합도 #강한 결합도
> #명시적인 의존성 #숨겨진 의존성


## 정리
1. 의존성 이해하기
- 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.
- 유연하고 재사용 가능한 설계를 창조하기 위해서는 동일한 소스코드 구조를 가지고 다양한 실행 구조를 만들 수 있어야 한다.

1-컨텍스트 독립성
- 클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안된다.
- 구체적인 클래스를 알면 알수록 그 클래스가 사용되는 특정한 문맥에 강하게 결합되기 때문이다.

1-의존성 해결
- 의존성 해결하기 위해 일반적으로 사용하는 세 가지 방법
  - 객체를 생성하는 시점에 생성자를 통해 의존성 해결
  - 객체 생성 후 setter 메서드를 통해 의존성 해결
  - 메서드 실행 시 인자를 이용해 의존성 해결

- 객체 생성 후 setter 메서드를 통해 전달하는 방식은
  - 객체가 생성된 후에 협력에 필요한 의존 대상을 설정하기 때문에 객체를 생성하고 의존 대상을 설정하기 전까지는 객체의 상태가 불완전할 수 있기 때문에 잘 사용하지 않는다.

- 클래스의 메서드를 호출하는 대부분의 경우에 매번 동일한 객체를 인자로 전달하고 있다며 `생성자를 이용하는 방식`이 좋을 것이다.
- 협력 대상에 대해 지속적으로 의존 관계를 맺을 필요 없이 메서드가 실행되는 동안만 일시적으로 의존 관계가 존재해도 무방하거나 메서드가 실행될 떄마다 의존 대상이 매번 달라져야 하는 경우에 `메서드 인자를 사용하는 방식`이 좋을 것이다.

> 스프링에서 빈은 쓰레드 세이프하지 않기 때문에 상태를 가지면 안 된다.

2. 유연한 설계
- 객체지향 패러다임의 근간은 협력이다.
- 객체들이 협력하기 위해서는 서로의 존재와 수행 가능한 책임을 알아야 한다.
- 이런 지식들이 객체 사이의 의존성을 낳지만 의존성이 과하면 문제가 될 수 있다.

- 이전에 두 가지 할인 정책을 런타임 시점에 결정할 수 있도록 인터페이스에 의존하는 방법이 있었고,
- 이번 장에서는 그렇게 하지 않는 것이 왜 나쁜 것인지,
- 어떻게 하는 것이 좋은 것인지에 대해 재사용성과 관련해서 설명되어 있다.


## 새롭게 다가온 부분
p.253
- 협력은 필수적이지만 과도한 협력은 설계를 곤경에 빠뜨릴 수 있다. 협력은 객체가 다른 객체에 대해 알 것을 강요한다.
- 다른 객체와 협력하기 위해서는 그런 객체가 존재한다는 사실을 알고 있어야 한다. 객체가 수신할 수 있는 메시지에 대해서도 알고 있어야 한다.
- 이런 지식이 객체 사이의 의존성을 낳는다.

- 객체 지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성을 제거하는 데 있다.

p.254
- 의존성은 실행 시점과 구현 시점에 서로 다른 의미를 가진다.
  - 실행 시점: 의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 읮ㄴ 대상 객체가 반드시 존재해야 한다.
  - 구현 시점: 의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

p.260
- 어떤 클래스의 인스턴스가 다양한 클래스의 인스턴스와 협력하기 위해서는 협력할 인스턴스의 구체적인 클래스를 알아서는 안된다.
- 실제로 `협력할 객체가 어떤 것인지는 런타임에서 해결`해야 한다.
- 클래스가 협력할 객체의 클래스를 명시적으로 드러내고 있다면 `다른 클래스의 인스턴스와 협력할 가능성` 자체가 없어진다.
- 따라서 컴파일타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연해지고 재사용 가능해진다.

p.261
- 의존성 해결하기 위해 일반적으로 사용하는 세 가지 방법
  - 객체를 생성하는 시점에 생성자를 통해 의존성 해결
  - 객체 생성 후 setter 메서드를 통해 의존성 해결
  - 메서드 실행 시 인자를 이용해 의존성 해결

p. 264
- 객체지향 패러다임의 근간은 협력이다.
- 객체들은 협력을 통해 애플리케이션에 생명력을 불어넣는다.
- 객체들이 협력하기 위해서는 서로의 존재와 수행 가능한 책임을 알아야 한다.
- 이런 지식들이 객체 사이의 의존성을 낳는다. 따라서 모든 의존성이 나쁜 것은 아니다.
- 의존성은 객체들의 협력을 가능하게 만드는 매개체라는 관점에서 바람직한 것이다.
- 하지만 의존성이 과하면 문제가 될 수 있다.

p.256, 266
- 컨텍스트에 독립적인 의존성은 바람직한 의존성이고
- 특정한 컨텍스트에 강하게 결합된 의존성은 바람직하지 않은 의존성이다.

- 이전까지는 의존성이 낮고 결합도가 낮을수록 좋다고 해서
- 객체지향 프로그래밍에서 결합도를 0(zero)으로 만드는 것이 가능한가에 대한 의문이 있었고 조금이라도 의존하고 있다면 어떻게 없앨까에 대한 고민을 했었는데,
- 바람직한 의존성에 대한 내용이 나와서 이해가 되기 시작했다.

p.268
- 추상화를 사용하면 현재 다루고 있는 문제를 해결하는 데 불필요한 정보를 감출 수 있다.
- 따라서 대상에 대해 알아야 하는 지식의 양을 줄일 수 있기 때문에 결합도를 느슨하게 유지할 수 있다.

> 실행 컨텍스트에 대해 알아야 하는 정보를 줄일수록 결합도가 낮아진다  
> - 결합도를 느슨하게 만들기 위해서는 구체적인 클래스보다 추상 클래스에,
> - 추상 클래스보다 인터페이스에 의존하도록 만드는 것이 더 효과적이다.
> - 즉, 의존하는 대상이 더 추상적일수록 결합도는 더 낮아진다.

- 인터페이스를 사용하는 것이 추상 클래스를 사용하는 것보다 왜 컨텍스트에 대해 알아야 하는 정보를 줄이는 것일까?
  - 인터페이스를 구현하는 클래스는 반드시 인터페이스가 갖고있는 메서드를 모두 구현해야 한다.
  - 따라서 이 클래스의 입장에서는 본인이 어떤 기능을 제공하는지를 외부에 따로 알리지 않아도 된다.
  - 따라서 인터페이스를 사용하면 컨텍스트에 대해 알아야 하는 정보를 줄일 수 있다.

  - 추상 클래스를 상속하는 클래스는 추상 클래스가 갖고 있는 메서드들 외의 본인만의 기능이 있다면,
  - 이를 외부에 구체적으로 알려야 하기 떄문에,
  - 추상 클래스를 사용하면 컨텍스트에 대해 알아야 하는 정보가 늘어날 것이다.
  
> 따라서 인터페이스를 사용하면 클래스가 제공하는 기능에 대한 추상화 수준이 높아지며,   
> 컨텍스트에 대한 정보를 줄일 수 있습니다.  
> 이로 인해 코드의 유지보수성이 향상되며, 코드 재사용성도 높아집니다


## 궁금한 부분


## 개념
- `의존성`: 의존하고 있는 대상의 변경에 영향을 받을 수 있는 가능성
- `의존성 해결`: 컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성을 교체하는 것
- `추상화`: 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법


## 한 줄 정리
- 의존성이 있는 것은 괜찮을 수 있지만, 바람직한 의존성을 갖고 있어야 한다!

> 결합도, 의존성 등에 대한 고민을 하고 난 뒤에  
> 바람직한 의존성에 대한 내용을 담은 것이  
> 고민을 충분히 해보라고 저자가 순서를 이렇게 설계해놓은 것일까..? 
