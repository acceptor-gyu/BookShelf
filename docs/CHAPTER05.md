# 오브젝트 - 5장 <책임 할당하기>

## 제목을 보고 든 생각
- 지금까지 책임을 강조했는데 이번 장에서 본격적으로 책임에 대한 이야기를 꺼내겠구나. 

## 목차
1. 책임 주도 설계를 향해
2. 책임 할당을 위한 GRASP 패턴
3. 구현을 통한 검증


## 이번 장의 목표
- 좋은 코드의 설계 과정을 따라가 보면서 객체에 책임을 할당하는 기본적인 원리를 이해하자.


## 읽으면서 쓴 단어들
1. 첵임 주도 설계를 향해
> #행동 #객체의 존재가치  
> #협력이라는 문맥 안에서 책임을 결정해라  
> #메시지 #메시지가 객체를 선택 #메시지 기반 설계

2. 책임 할당을 위한 GRASP 패턴
> #GRASP 패턴 #도메인 #도메인 모델 #정보 전문가  
> #협력 공동체

3. 구현을 통한 검증
> #변경의 이유 #인스턴스 변수 초기화 시점

4. 책임 주도 설계의 대안
> #


## 정리
1. 데이터 중심의 영화 예매 시스템
- 전체적으로 지금까지 책의 내용들과 비슷한 흐름이었고, 조금 더 구체적으로 설명해주는 느낌이 들었다.
- `메시지가 객체를 선택한다!` 이전에 나왔던 말이었지만 다시 봐도 인상 깊은 문장이었다.


2. 책임 할당을 위한 GRASP 패턴
- GRASP(General Responsibility Assignment Software Patter)
  - 일반적인 책임 할당을 위한 소프트웨어 패턴 

- p.138
  - 정보 전문가에게 책임을 할당하라.
    - 음... 먼저 적절한 객체에 책임을 할당하고 필요한 상태를 추가한다고 그랬는데
    - 정보 전문가는 어떻게 판단하는거지? 그럼 어느 정도의 상태는 알고 있어야 하는거 아닌가?
    - 아니면 내가 `정보`를 너무 `상태`에 매칭시켜놓고 바라보는건가?
  > 역시...
  > 여기서 이야기하는 정보는 데이터와 다르다는 사실에 주의하라고 했다.
  
- 책임을 객체에게 할당하는 과정을 보니까 도메인 모델이 설계의 시작으로 꽤나 중요한 부분이라는 생각이 들었다.



3. 구현을 통한 검증
- `코드를 수정해야 하는 이유는 하나여야만 한다`의 의미와
- `응집도가 낮다 또는 높다`의 의미가 
- 어느 정도 이해되기 시작했다.

<br>

- 추상 클래스와 인터페이스
  - 역할을 대체할 클래스들 사이에서` 구현을 공유해야 할 필요`가 있다면 `추상 클래스`를 사용하면 된다.
  - `구현을 공유할 필요 없이` 역할을 대체하는 객체들의 책임만 정의하고 싶다면 `인터페이스`를 사용하면 된다.

<br>

- 대부분 지금까지 나왔던 내용들이기 때문에 이해하기가 더 수월했다.

- 클래스를 먼저 나누고 필요한 상태들을 먼저 지정해놓고 시작하면 좋은 설계를 하기 위한 난이도가 훨씬 올라갈 것같다.

- 조금만 더 생각해보자!!
  - 어렵다는 말보다는 이와 같은 말을 하려고 노력한다.
  - 왜냐하면 어렵다라는 말을 하는 게 무의식적으로 자존감이 줄어드는 느낌이 드는 말이기 때문이다.
  - `쟤가 하는데 나는 왜 못해?` 마인드
    - 자만과는 다르지만 경계가 애매해질 수 있다.
    - 나 자신을 항상 경계하려고 한다. (내가 자만하는 것을 경계...)

4. 책임 주도 설계의 대안



    
## 새롭게 다가온 부분
p.135
- 협력을 시작하는 주체는 `메시지 전송자`이다.
- `메시지를 전송하는 클라이언트의 의도`에 적합한 책임을 할당해야 한다.

p.139
- 객체가 정보를 `알고` 있다고 해서 그 정보를 `저장`하고 있을 필요는 없다.
- 객체는 해당 정보를 제공할 수 있는 다른 객체를 알고 있거나 필요한 정보를 계산해서 제공할 수도 있다.
> 의문점이 해소된 부분이었다.  
> 사실 아마 여기서 정보와 데이터는 다른 것이라고 추상적으로는 생각하고 있었지만,  
> 항상 느낀 거지만, 명확하게 해소되지 않은 부분들을 이 책에서 말로 설명해주고 있었다.


p.140
- 또, 이전부터 갖고 있던 의문점이 해소된 부분이다.
- 왜?? 예매를 `Screening`에서 하는 거지??
  - Screening이 `예매하라`라는 책임의 정보 전문가였기 때문이었다.
  - 이 또한, 추상적으로 생각은 하고 있었지만 글로 명확하게 해소된 시점이었다.

p.142
- `INFORMATION EXPERT` 패턴을 따르는 것만으로도 자율성이 높은 객체들로 구성된 협력 공동체를 구축할 가능성이 높아지는 것이다.

p.152
- 낮은 응집도가 초래하는 문제를 해결하기 위해서는 `변경의 이유에 따라 클래스를 분리해야 한다.`
- 일반적으로 설계를 개선하는 작업은 변경의 이유가 하나 이상인 클래스를 찾는 것으로부터 시작하는 것이 좋다.
<br><br>
- 코드를 통해 변경의 이유 파악하기
  1. 인스턴스 변수가 초기화되는 시점 
     1. 응집도가 높은 클래스는 인스턴스를 생성할 때 모든 속성을 함께 초기화한다. 
     2. 함께 초기화되는 속성을 기준으로 코드를 분리해야 한다.
  2. 메서드들이 인스턴스 변수를 사용하는 방식
     1. 모든 메서드가 객체의 모든 속ㄷ성을 사용한다면 클래스의 응집도가 높다고 볼 수 있다.
     2. 클래스의 응집도를 높이기 위해서는 속성 그룹과 해당 그룹에 접근하는 메서드 그룹을 기준으로 코드를 분리해야 한다.


- 도메인 구조가 코드의 구조를 이끈다.
  - 구현을 가이드할 수 있는 도메인 모델을 선택하라!


p.165
- 요소들 사이의 의존성의 정도가 유연성의 정도를 결정한다.
  - 유연성의 정도에 따라 결합도를 조절할 수 있는 능력은 객체지향 개발자가 갖춰야 하는 중요한 기술 중 하나다.



## 다른 스터디원들에게 궁금한 부분
1/4 정도 읽은 이 시점에서 드는 생각: 본인만의 책을 읽는(내용을 이해하는) 방법이 있나요?
- 중간 중간 멈춰서 이전까지의 내용들과의 관계를 생각하면서 뒤의 내용을 대략적으로 예측하면서 읽는다.
- 반복되는 내용이 나올 것같으면 앞에서 나온 것을 적용시켜보고 넘어간다.
- 또는 이전까지의 내용을 적용하면서 읽었다.


돌고 돌아...
- 책임을 어떻게, 얼마나 나누지... ㅠㅡㅠ



## 개념
책임 주도 설계 방식
1. 애플리케이션이 제공해야 하는 기능을 애플리케이션의 책임으로 생각하는 것
   1. 이 책임을 애플리케이션에 대해 전송된 메시지로 간주하고 이 메시지를 책임질 첫 번째 객체를 선택하는 것으로 설계를 시작한다.

클래스 응집도 판단하기
- 클래스가 하나 이상의 이유로 변경돼야 한다면 응집도가 낮은 것이다.
  - 변경의 이유를 기준으로 클래스를 분리하라.
- 클래스의 인스턴스를 초기화하는 시점에 경우에 따라 서로 다른 속성들을 초기화하고 있다면 응집도가 낮은 것이다.
  - 초기화되는 속성의 그룹을 기준으로 클래스를 분리하라.
- 메서드 그룹이 속성 그룹을 사용하는지 여부로 나뉜다면 응집도가 낮은 것이다.
  - 이들 그룹을 기준으로 클래스를 분리하라.


POLYMORPHISM 패턴

PROTECTED VARIATIONS 패턴


## 한 줄 정리
- 객체에 책임을 할당하는 핵심은 `협력`에 있다!