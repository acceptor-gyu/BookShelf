# 오브젝트 - 13장 <서브클래싱과 서브타이핑>

## 제목을 보고 든 생각
- ??? 뭐지 ???

## 목차
1. 타입
2. 타입 계층
3. 서브클래싱과 서브타이핑
4. 리스코프 치환 원칙
5. 계약에 의한 설계와 서브타이핑

## 이번 장의 목표
- 상속을 통해 올바른 타입 계층을 구성하는 방법을 알고
- 상속과 서브타입 다형성, 동적 메서드 탐색과의 연관성을 알 수 있다.

## 읽으면서 쓴 단어들
> #상속 #타입 계층

1. 타입
> #타입 #심볼 #내연 #외연 #일반화 #구체화
> #오퍼레이션 #퍼블릭 인터페이스

2. 타입 계층
> #타입 #객체들의 집합 #슈퍼타입 #서브타입 #슈퍼셋 #서브셋

3. 서브클래싱과 서브타이핑
> #상속 #타입 계층 #is-a #행동 호환성 #클라이언트 관점
> #상속을 사용하는 목적 #서브클래싱 #서브타이핑

4. 리스코프 치환 원칙
> #행동 호환성 #대체 가능성 #클라이언트 #is-a

5. 계약에 의한 설계와 서브타이핑
> p,461 ~

## 정리
- 상속을 사용하는 일차적인 목표는 코드 재사용이 아니라 `타입 계층`을 구현하는 것이어야 한다.
  - 타입 계층 안에서 부모 클래스는 일반적인 개념을 구현하고 자식 클래스는 특수한 개념을 구현한다.
  - 타입 게층의 관점에서 부모 클래스는 자식 클래스의 `일반화(generalization)`이고 자식 클래스는 부모 클래스의 `특수화(specialization)`다.
  > 타입 계층을 목표로 상속을 사용하면 다형적으로 동작하는 객체들의 관계에 기반해 확장 가능하고 유연한 설계를 얻을 수 있다.

- 동일한 메시지에 대해 서로 다르게 행동할 수 있는 다형적인 객체를 구현하기 위해서는 객체의 `행동을 기반으로 타입 계층을 구성`해야 한다.
- 상속의 가치는 이러한 타입 계층을 구현할 수 있는 쉽고 편안한 방법을 제공한다는 데 있다.


1. 타입
- 타입은 심볼, 내연, 외연의 세 가지 요소로 구성된다.
  - `심볼(symbol)`: 타입에 이름을 붙인 것이다. 
  - `내연(intension)`: 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동을 가리킨다. 일반적으로 타입에 속하는 객체들이 공유하는 속성과 행동의 집합이 내연을 구성한다.
  - `외연(extension)`: 타입에 속하는 객체들의 집합이다.

- 프로그래밍 언어에서 타입은 두 가지 목적을 위해 사용된다.
  - > 타입에 수행될 수 있는 유요한 오퍼레이션의 집합을 정의한다.  
    - 자바에서 `+` 연산자는 원시형 숫자 타입이나 문자열 타입의 객체에는 사용할 수 있지만 다른 클래스의 인스턴스에 대해서는 사용할 수 없다.  
    - 하지만 C++와 C#에서는 연산자 오버로딩을 통해 `+` 연산자를 사용하는 것이 가능하다.  
    - 여기서 중요한 것은 모든 객체지향 언어들은 객체의 타입에 따라 적용 가능한 연산자의 종류를 제한함으로써 `프로그래머의 실수를 막아준다`는 것이다.
  - > 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다.
    - 예를 들어 자바에서 `a + b`라는 연산이 있을 떄 a와 b의 타입이 int라면 두 수를 더할 것이다. 하지만 a와 b의 타입이 String이라면 두 문자열을 하나의 문자열로 합칠 것이다.
    - 따라서 a와 b에 부여된 `타입이` `+` 연산자의 문맥을 정의한다.
    - 비슷한 예로 자바와 C#의 new 연산자는 타입에 정의된 크기만큼 저장공간을 할당하고 생성된 객체를 초기화하기 위해 타입의 생성자를 자동으로 호출한다.
    - 이 경우 객체를 생성하는 방법에 대한 문맥을 결정하는 것은 바로 `객체의 타입`이다.
> 타입은 적용 가능한 오퍼레이션의 종류와 의미를 정의함으로써 코드의 의미를 명확하게 전달하고 개발자의 실수를 방지하기 위해 사용된다.

- 객체지향 프로그래밍 관점에서 타입
  - `객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다. 따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류한다.`

> 객체를 바라볼 때 항상 객체가 외부에 제공하는 행동에 초점을 맞춰야 한다.  
> 객체의 타입을 결정하는 것은 내부의 속성이 아니라 객체가 `외부에 제공하는 행동`이라는 사실을 기억하라.


2. 타입 계층
- 타입 역시 객체들의 집합이기 때문에 다른 타입을 포함하는 것이 가능하다.
- 타입 안에 포함된 객체들을 좀 더 상세한 기준을 묶어 새로운 타입을 정의하면 이 새로운 타입은 자연스럽게 기존 타입의 부분집합이 된다.

- 일반화와 특수화 정의
  - > 일반화는 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.  
    특수화는 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.

- 내연과 외연의 관점에서 슈퍼타입
  - 집합이 다른 집합의 모든 멤버를 포함한다.
  - 타입 정의가 다른 타입보다 좀 더 일반적이다.
- 내연과 외연의 관점에서 서브 타입
  - 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다.
  - 타입 정의가 다른 타입보다 좀 더 구체적이다.

- 퍼블릭 인터페이스 관점에서
  - 슈퍼타입: 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것
  - 서브타입: 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것
> 일반적인 타입과 구체적인 타입 간의 관계를 형성하는 기준이 `퍼블릭 인터페이스`다.  
> 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다. 이 사실이 이번 장의 핵심이다!  
- 맞지! 다형성! 인터페이스!


3. 서브클래싱과 서브타이핑  
<클래스와 상속의 관점에서 타입 계층을 구현할 때 지켜야 하는 제약사항>

- 상속의 올바른 용도는 타입 계층을 구현하는 것이다. 아래 두 가지 조건을 만족하는 경우에만 상속을 사용하는 게 좋을 것이다.
  - 상속 관계가 is-a 관계를 모델링한다.
  - 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방하다.
> `is-a` 관계
> - 일반적으로 `[자식 클래스]는 [부모 클래스]다`라고 말해도 이상하지 않다면 상속을 사용할 후보로 간주할 수 있다.

> 부모 클래스의 타입으로 자식 클래스를 사용해도 무방하다.
> - 상속 계층을 사용하는 클라이언트의 입장에서 부모 클래스와 자식 클래스의 차이점을 몰라야 한다. 이를 자식 클래스와 부모 클래스 사이의 `행동 호환성`이라고 부른다.

- 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있다.
- 슈퍼타입과 서브타입 관계에서는 is-a보다 `행동 호환성`이 더 중요하다.


4. 리스코프 치환 원칙
- 대체 가능성을 결정하는 것은 클라이언트다!

- 클래스 상속은 타입 계층을 구현할 수 있는 다양한 방법 중 하나일 분이다.
- 구현 방법은 중요하지 않다,
- 핵심은 구현 방법과 무관하게 클라이언트의 관점에서 슈퍼타입에 대해 기대하는 모든 것이 서브타입에게도 적용돼야 한다는 것이다.


5. 계약에 의한 설계와 서브타이핑
- 클라이언트 관점에서 자식 클래스가 부모 클래스를 대체할 수 있다는 것은 무엇을 의미하는가?
- 클라이언트 관점에서 자식 클래스가 부모 클래스의 행동을 보존한다는 것은 무엇을 의미하는가?


## 새롭게 다가온 부분
p.437
- 비트 자체에는 타입이라는 개념이 존재하지 않는다.
- 비트에 담긴 데이터를 문자열로 다룰지, 정수로 다룰지는 전적으로 데이터를 사용하는 애플리케이션에 의해 결정된다.
- 프로그래밍 언어의 관점에서 타입은 비트 묶음에 의미를 부여하기 위해 정의된 제약과 규칙을 가리킨다.
- > `01010101`이라는 비트 묶음이 있으면 이 비트 묶음을 문자열이 될 지 정수가 될 지는 애플리케이션에 의해 결정된다.

p.438
- 개념 관점에서 타입: 공통의 특징을 공유하는 대상들의 분류
- 프로그래밍 언어 관점에서 타입: 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합
- 객체지향 프로그래밍에서 오퍼레이션은 객체가 수신할 수 있는 메시지를 의미한다.
  - 따라서 객체의 탕비이란 객체가 수신할 수 있는 메시지의 종류를 정의하는 것이다.
> 맞네...  
> 클래스를 만들고 그 클래스 안에 메서드를 만들면 해당 메서드는 해당 클래스 타입의 객체가 수신할 수 있다는 것!

p.438
- 객체에게 중요한 것은 속성이 아니라 `행동`이다!
- 어떤 객체들이 동일한 상태를 가지고 있더라도 `퍼블릭 인터페이스가 다르다면` 이들은 `서로 다른 타입`으로 분류된다.
- 반대로 어떤 객체들이 내부 상태는 다르지만 `동일한 퍼블릭 인터페이스`를 공유한다면 이들은 `동일한 타입`으로 분류된다.

p.440
- 타입이 다른 타입에 포함될 수 있기 때문에 동일한 인스턴스가 하나 이상의 타입으로 분류되는 것도 가능하다.
  - 알고 있던 내용이지만 당연하게 사용을 했었던 부분... 글로 정리해주니까 추상적으로 갖고있던 부채가 하나 사라진 느낌.

p.445
- 두 타입 사이에 행동이 호환될 경우에만 타입 계층으로 묶어야 한다.
- 중요한 것은 행동의 호환 여부를 판단하는 기준은 `클라이언트 관점`이라는 것이다.
  - 클라이언트가 두 타입이 동일하게 행동할 것이라고 기대한다면 두 타입을 타입 계층으로 묶을 수 있다.

p.451
- 설계가 꼭 현실 세계를 반영할 필요는 없다.
- 중요한 것은 설계가 반영할 도메인의 요구사항이고 그 안에서 클라이언트가 객체에게 요구하는 행동이다.
- `자연어에 현혹되지 말고 요구사항 속에서 클라이언트가 기대하는 행동에 집중하라`

p.453
- 행동 호환성
- 대체 가능성

p.458
- 클라이언트와 격리한 채로 본 모델은 의미 있게 검증하는 것이 불가ㅡㄴㅇ하다.
- 대체 가능성을 결정하는 것은 클라이언트다.


## 개념
- `심볼(symbol)`: 타입에 이름을 붙인 것이다.
- `내연(intension)`: 타입의 정의로서 타입에 속하는 객체들이 가지는 공통적인 속성이나 행동을 가리킨다. 일반적으로 타입에 속하는 객체들이 공유하는 속성과 행동의 집합이 내연을 구성한다.
- `외연(extension)`: 타입에 속하는 객체들의 집합이다.
- `퍼블릭 인터페이스`: 객체가 수신할 수 있는 메시지의 집합
- `슈퍼타입(supertype)`: 타입 계층을 구성하는 두 타입 간의 관계에서 더 일반적인 타입
- `서브타입(subtype)`: 타입 계층을 구성하는 두 타입 간의 관계에서 더 특수한 타입
- `슈퍼셋(superset)`: 집합을 의미하는 외연의 관점에서 일반적인 타입의 인스턴스 집합은 특수한 타입의 인스턴스 집합을 포함하는 `슈퍼셋(superset)`이다.
- `서브셋(subset)`: 집합을 의미하는 외연의 관점에서 특수한 타입의 인스턴스 집합은 일반적인 타입의 인스턴스 집합에 포함된 `서브셋(subset)`이다.

- `인터페이스 분리 원칙(Interface Segregation Principle, ISP)`: 인터페이스를 클라이언트의 기대에 따라 분리함으로써 변경에 의해 영향을 제어하는 설계 원칙

- `서브클래싱(subclassing)`: 다른 클래스의 코드를 재사용할 목적으로 상속을 사용하는 경우
  - > 자식 클래스와 부모 클래스의 행동이 호환되지 않기 떄문에 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 없다.
- `서브타이핑(subtyping)`: 타입 게층을 구성하기 위해 상속을 사용하는 경우
  - > 자식 클래스의 인스턴스가 부모 클래스의 인스턴스를 대체할 수 있다. 서브타이핑을 `인터페이스 상속(interface inheritance)`이라고 부르기도 한다.

- `리스코프 치환 원칙`: 서브타입은 그것의 기반 타입에 대해 대체 가능해야 한다.
  - 즉, 클라이언트가 차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브 클래스를 사용할 수 있어야 한다.


## 한 줄 정리
- 서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다.!
  - 동일한 인스턴스가 하나 이상의 타입으로 분류되는 것 -> 다형성!